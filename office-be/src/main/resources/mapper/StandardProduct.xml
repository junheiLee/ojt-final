<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.ojt_final.office.dao.StandardProdDao">

    <insert id="saveAll" parameterType="StandardProd">
        INSERT INTO tStandardProduct (
                    nProductCode,
                    nCategoryCode,
                    sProductName,
                    sBundleCondition,
                    sDescription,
                    dtManufactureDate
        )
        VALUES
            <foreach collection="list" item="StandardProd" separator="," >
                (
                #{StandardProd.code},
                #{StandardProd.categoryCode},
                #{StandardProd.name},
                #{StandardProd.bundleCondition},
                #{StandardProd.description},
                #{StandardProd.manufactureDate}
                )
            </foreach>
        ON DUPLICATE KEY UPDATE
                sProductName = VALUES(sProductName),
                nCategoryCode = VALUES(nCategoryCode),
                sDescription = VALUES(sDescription ),
                dtManufactureDate = VALUES(dtManufactureDate)
    </insert>

    <select id="countAll">
        SELECT COUNT(nProductCode)
        FROM tStandardProduct
    </select>

    <select id="selectByCond" parameterType="StandardProdCond" resultType="StandardProd">
        SELECT C.sCategoryName AS categoryName,
               SP.nProductCode AS code,
               SP.sProductName AS name,
               SP.sImageUrl AS imageUrl,
               SP.nMinPrice AS minPrice,
               SP.nMinPcPrice AS minPcPrice,
               SP.nMinMobilePrice AS minMobilePrice,
               SP.nAvgPrice AS avgPrice,
               SP.nPartnerCount AS partnerCount
        FROM tStandardProduct SP
        INNER JOIN tCategory C ON (SP.nCategoryCode = C.nCategoryCode)
        <where>
            <if test="categoryCode != null and categoryCode != ''">
                AND SP.nCategoryCode = #{categoryCode}
            </if>
        </where>
        <trim prefix="ORDER BY" prefixOverrides=",">
            <if test="sort.name == ''
                  and sort.minPrice == ''
                  and sort.minPcPrice == ''
                  and sort.minMobilePrice == ''
                  and sort.partnerCount == ''">
                ,nProductCode DESC
            </if>
            <if test="sort.name != '' and sort.name == 'ASC'"> , sProductName ASC </if>
            <if test="sort.name != '' and sort.name == 'DESC'"> , sProductName DESC </if>
            <if test="sort.minPrice != '' and sort.minPrice == 'ASC'"> , nMinPrice ASC </if>
            <if test="sort.minPrice != '' and sort.minPrice == 'DESC'"> , nMinPrice DESC </if>
            <if test="sort.minPcPrice != '' and sort.minPcPrice == 'ASC'"> , nMinPcPrice ASC </if>
            <if test="sort.minPcPrice != '' and sort.minPcPrice == 'DESC'"> , nMinPcPrice DESC </if>
            <if test="sort.minMobilePrice != '' and sort.minMobilePrice == 'ASC'"> , nMinMobilePrice ASC </if>
            <if test="sort.minMobilePrice != '' and sort.minMobilePrice == 'DESC'"> , nMinMobilePrice DESC </if>
            <if test="sort.partnerCount != '' and sort.partnerCount == 'ASC'"> , nPartnerCount ASC </if>
            <if test="sort.partnerCount != '' and sort.partnerCount == 'DESC'"> , nPartnerCount DESC </if>
        </trim>
        LIMIT #{limit}
        OFFSET #{offset}
    </select>

    <select id="countByCond">
        SELECT COUNT(nProductCode)
        FROM tStandardProduct
        <where>
            <if test="categoryCode != null">
                nCategoryCode = #{categoryCode}
            </if>
        </where>
    </select>

    <update id="integrateChange">
        UPDATE tStandardProduct SP
        INNER JOIN (
            SELECT
                L.nProductCode,
                MIN(PP.nPcPrice) AS minPcPrice,
                MIN(PP.nMobilePrice) AS minMobilePrice,
                LEAST(MIN(PP.nPcPrice), MIN(PP.nMobilePrice)) AS minPrice,
                AVG(PP.nPcPrice + PP.nMobilePrice)/2 AS avgPrice,
                COUNT(DISTINCT PP.sPartnerCode) AS partnerCount
            FROM tLink L
            INNER JOIN tPartnerProduct PP
                    ON (L.sPartnerProductCode = PP.sPartnerProductCode)
            GROUP BY L.nProductCode
            ) CAL
        ON (SP.nProductCode = CAL.nProductCode)
        SET SP.nMinPcPrice = CAL.minPcPrice,
            SP.nMinMobilePrice = CAL.minMobilePrice,
            SP.nMinPrice = CAL.minPrice,
            SP.nAvgPrice = CAL.avgPrice,
            sp.nPartnerCount = CAL.partnerCount
        <where>
            <if test="list != null and list.size() != 0">
                SP.nProductCode IN (
                <foreach collection="list" item="code" separator=", ">
                    #{code}
                </foreach>
                )
            </if>
        </where>
    </update>
</mapper>
